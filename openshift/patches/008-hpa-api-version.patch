diff --git a/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2/horizontalpodautoscaler/horizontalpodautoscaler.go b/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2/horizontalpodautoscaler/horizontalpodautoscaler.go
index 009c0168d..47bcd9d41 100644
--- a/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2/horizontalpodautoscaler/horizontalpodautoscaler.go
+++ b/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2/horizontalpodautoscaler/horizontalpodautoscaler.go
@@ -33,6 +33,7 @@ import (
 	controller "knative.dev/pkg/controller"
 	injection "knative.dev/pkg/injection"
 	logging "knative.dev/pkg/logging"
+	"knative.dev/serving/pkg/reconciler/autoscaling/hpakey"
 )

 func init() {
@@ -46,6 +47,7 @@ type Key struct{}
 func withInformer(ctx context.Context) (context.Context, controller.Informer) {
 	f := factory.Get(ctx)
 	inf := f.Autoscaling().V2().HorizontalPodAutoscalers()
+	ctx = context.WithValue(ctx, hpakey.IdentifiableKey{}, inf)
 	return context.WithValue(ctx, Key{}, inf), inf.Informer()
 }

diff --git a/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2beta2/horizontalpodautoscaler/horizontalpodautoscaler.go b/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2beta2/horizontalpodautoscaler/horizontalpodautoscaler.go
index 45f38dd15..23bc80bd4 100644
--- a/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2beta2/horizontalpodautoscaler/horizontalpodautoscaler.go
+++ b/vendor/knative.dev/pkg/client/injection/kube/informers/autoscaling/v2beta2/horizontalpodautoscaler/horizontalpodautoscaler.go
@@ -33,6 +33,7 @@ import (
 	controller "knative.dev/pkg/controller"
 	injection "knative.dev/pkg/injection"
 	logging "knative.dev/pkg/logging"
+	"knative.dev/serving/pkg/reconciler/autoscaling/hpakey"
 )

 func init() {
@@ -46,6 +47,7 @@ type Key struct{}
 func withInformer(ctx context.Context) (context.Context, controller.Informer) {
 	f := factory.Get(ctx)
 	inf := f.Autoscaling().V2beta2().HorizontalPodAutoscalers()
+	ctx = context.WithValue(ctx, hpakey.IdentifiableKey{}, inf)
 	return context.WithValue(ctx, Key{}, inf), inf.Informer()
 }

diff --git a/vendor/knative.dev/pkg/injection/informers.go b/vendor/knative.dev/pkg/injection/informers.go
index ce5d481e8..39be6ebd0 100644
--- a/vendor/knative.dev/pkg/injection/informers.go
+++ b/vendor/knative.dev/pkg/injection/informers.go
@@ -18,10 +18,17 @@ package injection

 import (
 	"context"
-
+	"fmt"
+	"strings"
+
+	"github.com/blang/semver/v4"
+	"k8s.io/client-go/discovery"
+	v2 "k8s.io/client-go/informers/autoscaling/v2"
+	"k8s.io/client-go/informers/autoscaling/v2beta2"
+	"k8s.io/client-go/kubernetes"
 	"k8s.io/client-go/rest"
-
 	"knative.dev/pkg/controller"
+	"knative.dev/serving/pkg/reconciler/autoscaling/hpakey"
 )

 // InformerInjector holds the type of a callback that attaches a particular
@@ -116,6 +123,12 @@ func (i *impl) SetupInformers(ctx context.Context, cfg *rest.Config) (context.Co
 		ctx = duck(ctx)
 	}

+	kc := kubernetes.NewForConfigOrDie(cfg)
+	useHPAV2 := false
+	if err := CheckMinimumVersion(kc.Discovery(), "1.24.0"); err == nil {
+		useHPAV2 = true
+	}
+
 	// Based on the reconcilers we have linked, build up a set of informers
 	// and inject them onto the context.
 	var inf controller.Informer
@@ -123,6 +136,24 @@ func (i *impl) SetupInformers(ctx context.Context, cfg *rest.Config) (context.Co
 	informers := make([]controller.Informer, 0, len(i.GetInformers()))
 	for _, ii := range i.GetInformers() {
 		ctx, inf = ii(ctx)
+
+		// We put the hpa informers on the context with a known key,
+		// so we can avoid having both informers started.
+		// The informer will still be on the context, but will not be run by the
+		// calling function.
+		hpaInf := ctx.Value(hpakey.IdentifiableKey{})
+		if v2beta2Inf, ok := hpaInf.(v2beta2.HorizontalPodAutoscalerInformer); ok {
+			if useHPAV2 && v2beta2Inf.Informer() == inf {
+				continue
+			}
+		}
+
+		if v2Inf, ok := hpaInf.(v2.HorizontalPodAutoscalerInformer); ok {
+			if !useHPAV2 && v2Inf.Informer() == inf {
+				continue
+			}
+		}
+
 		informers = append(informers, inf)
 	}
 	for _, fii := range i.GetFilteredInformers() {
@@ -132,3 +163,44 @@ func (i *impl) SetupInformers(ctx context.Context, cfg *rest.Config) (context.Co
 	}
 	return ctx, informers
 }
+
+// CheckMinimumVersion checks if current K8s version we are on is higher than the one passed.
+// An error is returned if the version is lower.
+// Based on implementation in SO: https://github.com/openshift-knative/serverless-operator/blob/main/openshift-knative-operator/pkg/common/api.go#L134
+func CheckMinimumVersion(versioner discovery.ServerVersionInterface, version string) error {
+	v, err := versioner.ServerVersion()
+	if err != nil {
+		return err
+	}
+	currentVersion, err := semver.Make(normalizeVersion(v.GitVersion))
+	if err != nil {
+		return err
+	}
+
+	minimumVersion, err := semver.Make(normalizeVersion(version))
+	if err != nil {
+		return err
+	}
+
+	// If no specific pre-release requirement is set, we default to "-0" to always allow
+	// pre-release versions of the same Major.Minor.Patch version.
+	if len(minimumVersion.Pre) == 0 {
+		minimumVersion.Pre = []semver.PRVersion{{VersionNum: 0, IsNum: true}}
+	}
+
+	if currentVersion.LT(minimumVersion) {
+		return fmt.Errorf("kubernetes version %q is not compatible, need at least %q",
+			currentVersion, minimumVersion)
+	}
+	return nil
+}
+
+// using versionwrapper.CheckMinimumVersion will cause a cycle, thus
+// this method is duplicated
+func normalizeVersion(v string) string {
+	if strings.HasPrefix(v, "v") {
+		// No need to account for unicode widths.
+		return v[1:]
+	}
+	return v
+}
